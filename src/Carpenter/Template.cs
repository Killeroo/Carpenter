using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;

namespace Carpenter
{
    public class Template
    {
        private class TemplateSection
        {
            public string Element;
            public string?[] Contents;
            public string StartLine;
            public string EndLine;
            public int Length;

            // Start and end indexes in the original template array
            public int StartIndex;
            public int EndIndex;

            private readonly Template _template;

            public TemplateSection(Template template, int index)
            {
                _template = template;
                Parse(index);
            }

            private void Parse(int index)
            {
                string line = _template._fileContents[index];

                // Ok great what element is it
                Element = _template.ParseElement(line, index);

                if (line.Contains(@"/>") || line.Contains(@"</"))
                {
                    // Replace the end of the element, we are going to need it to span
                    // over multiple lines
                    line = line.Replace(@"/>", @">");

                    // TODO: Properly strip </div> on the same line

                    // Special case where the element was self contained,
                    // so the end element would be on the next line
                    EndIndex = index + 1;
                    EndLine = $"{line.CopyTill('<')}</{Element}>";
                }
                else
                {
                    // Find the index where the element ends
                    EndIndex = _template.ParseTillElementEnds(index + 1, Element);
                    EndLine = _template._fileContents[EndIndex];
                }

                // Save the line so we can use it in generation later
                StartIndex = index;
                StartLine = line;

                Length = EndIndex - StartIndex + 1;

                // Now lets copy over what is between the start and end elements (if we can)
                if (Length > 1)
                {
                    Contents = new string[Length];
                    int destinationIndex = 0;
                    for (int i = StartIndex; i <= EndIndex; i++)
                    {
                        Contents[destinationIndex] = _template._fileContents[i];
                        destinationIndex++;
                    }
                }
            }

            private void Dump()
            {
                Console.WriteLine($"Element={Element}");
                Console.WriteLine($"StartLine={StartLine}");
                Console.WriteLine($"EndLine={EndLine}");
                Console.WriteLine($"Length={Length}");
                Console.WriteLine($"StartIndex={StartIndex}");
                Console.WriteLine($"EndIndex={EndIndex}");

                if (Contents != null)
                {
                    foreach (string line in Contents)
                    {
                        Console.WriteLine(line);
                    }
                }
            }
        }

        private const string kGeneratedComment = "<!-- Generated by Carpenter, Static Website Generator (https://github.com/Killeroo/Carpenter), at {0} UTC -->";
        private const int kNumImagesWithoutLazyLoading = 4;

        public string FilePath => _path;
        public bool IsLoaded => _loaded;

        private TemplateSection _imageGridSection;
        private TemplateSection _imageSection;
        private TemplateSection _imageColumnSection;
        private TemplateSection _imageTitleSection;
        private string[] _fileContents;
        private string _path = string.Empty;
        private bool _loaded = false;

        public Template() 
        {
            // Setup Jpeg parser library 
            JpegParser.UseInternalCache = true;
            JpegParser.CacheSize = 1;
        }
        public Template(string path) : this() => Load(path);

        public void Load(string path)
        {
            _fileContents = File.ReadAllLines(path);
            _path = path;
            Logger.Log(LogLevel.Verbose, $"Template file loaded (\"{path}\")");
            _loaded = true;
        }

        public bool GeneratePreviewHtmlForSchema(Schema schema, string outputPath)
        {
            if (schema.OptionValues.TryGetValue(Schema.Options.OutputFilename, out string outputFilename))
            {
                outputFilename = string.Format("{0}_preview.html", Path.GetFileNameWithoutExtension(outputFilename));
                return GenerateHtml(schema, outputPath, outputFilename, true);
            }

            return false;
        }

        public bool GenerateHtmlForSchema(Schema schema, string outputPath)
        {
            if (schema.OptionValues.TryGetValue(Schema.Options.OutputFilename, out string outputFilename))
            {
                return GenerateHtml(schema, outputPath, outputFilename, false);
            }

            return false;
        }

        // TODO: Throw some exceptions
        Dictionary<string, (int height, int width)> _schemaImages = new Dictionary<string, (int height, int width)>();
        private bool GenerateHtml(Schema schema, string outputPath, string outputFilename, bool isPreview)
        {
            if (!_loaded)
            {
                Logger.Log(LogLevel.Error, "Cannot generate page without template loaded. Call load() first.");
                return false;
            }

            // Store a list of image size so we can use those when generating the img tags
            // HACK: Assumes output directory also contains images
            _schemaImages.Clear();
            ImageMetadata metadata;
            Logger.Log(LogLevel.Verbose, $"Caching image sizes in {outputPath}...");
            foreach (string imagePath in Directory.GetFiles(outputPath, "*.jpg"))
            {
                // Fetch image dimensions
                int width = 0, height = 0;

                // TEMP: Comment out so we can diagnose and harden the jpgparser
                //try
                {
                    metadata = JpegParser.GetMetadata(imagePath);
                    width = metadata.Width;
                    height = metadata.Height;
                }
                //catch (Exception)
                //{
                //    // If we encounter an error then we fall back on reading the medata using C#'s GDI Image interface
                //    // (it's slower and more memory intensive)
                //    System.Drawing.Image image = System.Drawing.Image.FromFile(imagePath);
                //    width = image.Width;
                //    height = image.Height;
                //    image.Dispose();
                //}

                _schemaImages.Add(Path.GetFileName(imagePath), (height, width));
            }

            // Parse first to understand the template using the schema 
            // We need to do this before we can generate the file
            Parse(schema);

            // Ok next we need to modify the template and remove the sections we have just passed
            // TODO: Don't assume sections are nested and that photo grid is first...
            List<string> templateCopy = _fileContents.RemoveSection(_imageGridSection.StartIndex, _imageGridSection.EndIndex).ToList();

            // Next lets build our photo grid
            string[] photoGridContents = GeneratePhotoGrid(schema);
            Logger.Log(LogLevel.Verbose, $"PhotoGrid generated");

            // Ok add it to the template copy where the image grid was in the template
            templateCopy.InsertRange(_imageGridSection.StartIndex, photoGridContents);

            // We are almost there, go through the copy and replace all tokens with values from the schema
            for (int i = 0; i < templateCopy.Count; i++)
            {
                string line = templateCopy[i];

                if (string.IsNullOrEmpty(line))
                    continue;

                foreach (var token in schema.TokenTable)
                {
                    line = line.Replace(token.Key, schema._tokenValues[token.Value]);
                }

                templateCopy[i] = line;
            }
            Logger.Log(LogLevel.Verbose, $"All tokens in template file replaced");

            // Add generated timestamp
            templateCopy.Insert(0, "");
            templateCopy.Insert(0, string.Format(kGeneratedComment, DateTime.Now.ToString("yyyy'-'MM'-'dd' 'HH':'mm''")));

            // Remove urls so images on page render correctly in preview mode
            if (isPreview)
            {
                for (int index = 0; index < templateCopy.Count; index++)// (string line in templateCopy)
                {
                    string line = templateCopy[index];

                    if (string.IsNullOrEmpty(line))
                    {
                        continue;
                    }

                    // Replace page url
                    string pageUrl = string.Format("{0}/{1}/", schema._tokenValues[Schema.Tokens.BaseUrl], schema._tokenValues[Schema.Tokens.PageUrl]);
                    line = line.Replace(pageUrl, "");

                    templateCopy[index] = line;
                }
            }

            // Great now save the file out
            try
            {
                string generatedFilePath = Path.Combine(outputPath, outputFilename);
                File.WriteAllLines(generatedFilePath, templateCopy);
                Logger.Log(LogLevel.Info, $"File generated: {generatedFilePath}");

                return true;
            }
            catch (Exception e)
            {
                Logger.Log(LogLevel.Error, $"[{e.GetType()}] Could not create generated file - {e.Message}");
                return false;
            }
        }

        // TODO: Tab consistently for nested elements
        private int _processedImages = 0;
        private string[] GeneratePhotoGrid(Schema schema)
        {
            List<string> photoGridContents = new List<string>();
            _processedImages = 0;

            photoGridContents.Add(_imageGridSection.StartLine);
            foreach (ImageSection section in schema.ImageSections)
            {
                if (section.GetType() == typeof(StandaloneImageSection))
                {
                    CreateImageElement(schema, section as StandaloneImageSection, ref photoGridContents);
                    _processedImages++;
                }
                else if (section.GetType() == typeof(ColumnImageSection))
                {
                    ColumnImageSection columnSection = section as ColumnImageSection;

                    photoGridContents.Add(_imageColumnSection.StartLine);
                    foreach (StandaloneImageSection imageSection in columnSection.Sections)
                    {
                        CreateImageElement(schema, imageSection, ref photoGridContents);
                    }
                    photoGridContents.Add(_imageColumnSection.EndLine);
                    _processedImages++;
                }
                else if (section.GetType() == typeof(TitleImageSection))
                {
                    CreateTitleElement(schema, section as TitleImageSection, ref photoGridContents);
                }

            }
            photoGridContents.Add(_imageGridSection.EndLine);

            return photoGridContents.ToArray();
        }

        private void CreateImageElement(Schema schema, StandaloneImageSection section, ref List<string> outputContent)
        {
            // Load the template html we are using for the image
            string[] imageTemplate = _imageSection.Contents;

            // Iterate through it and replace it with the contents of the StandaloneImageSection
            for (int i = 0; i < imageTemplate.Length; i++)
            {
                string line = imageTemplate[i];

                // Replace all image tokens with the values in the StandaloneImageSection
                foreach (var imageTokenEntry in schema.ImageTokenTable)
                {
                    switch (imageTokenEntry.Value)
                    {
                        case Schema.Tokens.Image:
                            line = line.Replace(imageTokenEntry.Key, section.PreviewImage);
                            break;

                        case Schema.Tokens.DetailedImage:
                            line = line.Replace(imageTokenEntry.Key, section.DetailedImage);
                            break;
                    }
                }

                // Remove lazy loading attribute for first few images
                if (_processedImages < kNumImagesWithoutLazyLoading)
                {
                    line = line.Replace("loading=\"lazy\"", "");
                }


                if (_schemaImages.ContainsKey(section.PreviewImage))
                {
                    line = line.Replace("%HEIGHT", _schemaImages[section.PreviewImage].height.ToString());
                    line = line.Replace("%WIDTH", _schemaImages[section.PreviewImage].width.ToString());
                }
                else
                {
                    Logger.Log(LogLevel.Warning, $"Could not find referenced image ({section.PreviewImage}) in directory, generated file might not render properly");
                }

                // Add the modified line into the outputted html
                outputContent.Add(line);
            }
        }

        private void CreateTitleElement(Schema schema, TitleImageSection section, ref List<string> outputContent)
        {
            // Load the template html we are using for the title
            string[] titleTemplate = _imageTitleSection.Contents;

            // Iterate through it and replace it with the contents of the StandaloneImageSection
            for (int i = 0; i < titleTemplate.Length; i++)
            {
                string line = titleTemplate[i];

                // Replace all image tokens with the values in the StandaloneImageSection
                foreach (var imageTokenEntry in schema.ImageTokenTable)
                {
                    if (imageTokenEntry.Value == Schema.Tokens.ImageTitle)
                    {
                        line = line.Replace(imageTokenEntry.Key, section.TitleText);
                    }
                }

                // Add the modified line into the outputted html
                outputContent.Add(line);
            }
        }

        /// <summary>
        /// We need to parse the template using the schema to understand some basics about how things
        /// will be laid out
        /// </summary>
        private void Parse(Schema schema)
        {
            // Reset everything so we don't end up having data from another schema
            _imageSection = null;
            _imageColumnSection = null;
            _imageGridSection = null;
            _imageTitleSection = null;

            // Loop through the file contents to find each relevant section of the template
            // (The schema contains the class identifiers that represent where everything should go)
            for (int i = 0; i < _fileContents.Length; i++)
            {
                string line = _fileContents[i];

                if (line.Contains($"class=") && line.Contains(schema._tokenValues[Schema.Tokens.ClassIdImageGrid]))
                {
                    // First we need to find of the template that corresponds to our photo grid
                    _imageGridSection = new TemplateSection(this, i);
                    Logger.Log(LogLevel.Verbose, $"Found ImageGrid element (id={schema._tokenValues[Schema.Tokens.ClassIdImageGrid]})");
                }
                else if (line.Contains($"class=") && line.Contains(schema._tokenValues[Schema.Tokens.ClassIdImageElement]))
                {
                    // Next we need to find the second of the template that makes up the element for our image
                    _imageSection = new TemplateSection(this, i);
                    Logger.Log(LogLevel.Verbose, $"Found ImageSection element (id={schema._tokenValues[Schema.Tokens.ClassIdImageElement]})");
                }
                else if (line.Contains($"class=") && line.Contains(schema._tokenValues[Schema.Tokens.ClassIdImageColumn]))
                {
                    _imageColumnSection = new TemplateSection(this, i);
                    Logger.Log(LogLevel.Verbose, $"Found ImageColumn element (id={schema._tokenValues[Schema.Tokens.ClassIdImageColumn]})");
                }
                else if (schema.TokenValues.ContainsKey(Schema.Tokens.ClassIdImageTitle) && line.Contains($"class=") && line.Contains(schema._tokenValues[Schema.Tokens.ClassIdImageTitle]))
                {
                    _imageTitleSection = new TemplateSection(this, i);
                    Logger.Log(LogLevel.Verbose, $"Found ImageTitle element (id={schema._tokenValues[Schema.Tokens.ClassIdImageTitle]})");
                }
            }

            if (_imageSection == null || _imageColumnSection == null || _imageGridSection == null || _imageTitleSection == null)
            {
                Logger.Log(LogLevel.Error, "Did not parse all sections of template file");
                Debug.Assert(true); // TODO: Not great really
            }
            else
            {
                Logger.Log(LogLevel.Verbose, $"Template file parsed using Schema, all elements found");
            }
        }

        private int ParseTillElementEnds(int startIndex, string elementIdentifier)
        {
            // Keep track of each element we encounter, what element it was and where we found it
            // so that we avoid thinking that our element has ended when it was infact the terminator
            // for a nested element
            Dictionary<int, string> duplicateElementTracker = new Dictionary<int, string>();

            for (int i = startIndex; i < _fileContents.Length; i++)
            {
                string line = _fileContents[i];

                if (line.Contains("</"))
                {
                    string element = ParseElement(line, i);

                    // Ok does this element match the one we are looking for
                    // and have we come accross no other nested elements of the same type
                    if (element.Equals(elementIdentifier))
                    {
                        if (!duplicateElementTracker.Values.Contains(elementIdentifier))
                        {
                            // We found the end, return the index we are at
                            return i;
                        }
                        else
                        {
                            // Ok so this belongs to a nested element
                            // Find the occurance that is closest to our current index
                            // and remove it, that is obviously the element that is closing
                            int closestKey = duplicateElementTracker.FindClosestKey(i);
                            duplicateElementTracker.Remove(closestKey);
                            continue;
                        }
                    }
                }

                // if line contains an element with the same name
                // as the one we are looking for 
                // we need to track it
                if (line.Contains('<') && !line.Contains("/>"))
                {
                    string element = ParseElement(line, i);
                    if (element.Equals(elementIdentifier))
                    {
                        // track it
                        duplicateElementTracker.Add(i, element);
                    }
                }
            }

            // We didn't find it 
            return -1;
        }

        private string ParseElement(string line, int index)
        {
            // Strip starting whitespaces and convert to character array
            line = line.TrimStart(' ');
            line = line.TrimStart('\t');
            char[] characters = line.ToCharArray();

            // Check the first character is valid
            if (characters[0] != '<')
            {
                Logger.Log(LogLevel.Error, $"Line {index + 1} of template file doesn't start with '<', invalid html. check template file and try again.");
                return string.Empty;
                //throw new argumentexception($"line {index + 1} of template file doesn't start with '<', invalid html. check template file and try again.");
            }

            // Parse all leading characters to crudley get the element string (till we hit a whitespace)
            string elementType = "";
            int maxCount = 50;
            int count = 0;
            foreach (var @char in characters)
            {
                if (count > maxCount)
                {
                    Logger.Log(LogLevel.Error, $"Element too long (50+ characters), bailing. Final element string={elementType}");
                    break;
                }
                else
                {
                    count++;
                }

                if (char.IsWhiteSpace(@char) || @char.Equals('>'))
                {
                    // Remove terminator start cone
                    elementType = elementType.Replace(@"</", "");
                    elementType = elementType.Replace(">", "");

                    // Remove the start cone from the element name
                    return elementType.TrimStart('<');
                }
                else
                {
                    elementType += @char;
                }
            }

            return string.Empty;
        }
    }
}
